package safety

import (
	"bytes"
	"strings"
	"text/template"
)

var guardTemplate = template.Must(template.New("guard").Parse(`#!/usr/bin/env bash
# safety-guard.sh — Generated by agtop init
# Claude Code PreToolUse hook that blocks dangerous commands.
# Exit code 2 = block tool execution. Exit code 0 = allow.
# See: https://docs.anthropic.com/en/docs/claude-code/hooks

set -euo pipefail

# Read the tool input JSON from stdin
INPUT=$(cat)

# Extract the command field (jq with grep/sed fallback)
if command -v jq &>/dev/null; then
  COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty' 2>/dev/null)
else
  COMMAND=$(echo "$INPUT" | grep -o '"command"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"command"[[:space:]]*:[[:space:]]*"\(.*\)"/\1/' 2>/dev/null || true)
fi

if [ -z "$COMMAND" ]; then
  exit 0  # No command field — not a Bash tool call, allow
fi

# Blocked patterns (from agtop.yaml safety.blocked_patterns)
{{- range .Patterns}}
if [[ "$COMMAND" =~ {{.}} ]]; then
  echo "BLOCKED by agtop safety: pattern '{{.}}' matched" >&2
  exit 2
fi
{{- end}}

exit 0
`))

// bashSafe reports whether a pattern can be safely embedded in
// a bash [[ =~ ]] test and a double-quoted echo string.
func bashSafe(pattern string) bool {
	// ]] closes the [[ conditional prematurely
	if strings.Contains(pattern, "]]") {
		return false
	}
	for _, c := range pattern {
		switch c {
		case '"':
			return false // breaks double-quoted echo string
		case '`':
			return false // backtick command substitution in echo
		case '\n', '\r':
			return false // breaks if statement across lines
		}
	}
	// $( triggers command substitution inside double quotes
	if strings.Contains(pattern, "$(") {
		return false
	}
	return true
}

func renderGuardScript(patterns []string) string {
	var safe []string
	for _, p := range patterns {
		if bashSafe(p) {
			safe = append(safe, p)
		}
	}
	var buf bytes.Buffer
	_ = guardTemplate.Execute(&buf, struct{ Patterns []string }{Patterns: safe})
	return buf.String()
}
